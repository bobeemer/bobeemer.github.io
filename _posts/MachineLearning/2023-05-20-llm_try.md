---

layout: post
title: 如何应用LLM
category: 架构
tags: MachineLearning
keywords: llm chatgpt gpt bert

---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 简介

* TOC
{:toc}

所有产品都值得用AI去重新做一遍。其根本原因在于当下AI的形态即生成式模型是通过AI辅助来改变和创造新的产品形态，而不是像以往的技术一样只是对现有产品形态的补充。简单来说，产品研发同学可以做的事情更多了。

早期的深度模型专模专用，严重依赖有监督学习，这就需要大量的任务相关的人工标注数据，代价昂贵。天下苦标注久矣，如果能够有一个与具体任务无关的大模型，只要利用任务相关的少量数据微调，就能够大杀四方，岂不美哉。

ChatGPT 的技术结构，大家应该都有被科普到，其实就相当于续写，我们给出上半段，它来生成后半段，所以也被叫做生成式的预训练 Transformer 。而所谓的涌现出的能力，可以理解为我们给它提出不同的问题，它在续写的过程中，或者在不同的能力表现上，达标了过线了，再或者说，能力可用了。随着模型参数指数级的增长，之前，很多问题上不及格的回答，逐步变得及格、变得可用，这就是涌现的逻辑。当然，从结构上来说，大模型是一个数学逻辑，也就是说，底层是数学或者计算，但运作方式上是语文，所有问题，都以对话的形式予以反馈，而它表现出的能力却又是跨学科的。所以我们可以从不同的层面上，用不同的词来形容它。但底层的根本能力，都是计算。这就有点像我们上学时说的题海战术。所谓题海战术，就是我们做的题多了，看到题干，就知道要写什么答案，这个过程，我们可能并没有过多的思考或者甚至没有思考。而对于大模型来说，我们喂给它的语料，就相当于海量的题目，当大模型收到某一个类似的题目时，也就能自然地给出答案。

大模型在两个方面有得天独厚的优势
1. 理解能力很强，可以准确的理解人类的自然语音到底是什么意思。
2. 推理能力很强，可以根据已有的信息，推断接下来要做什么。

![](/public/upload/machine/llm_usage.png)

Andrej Karpathy 在 2017 年提出的 Software 2.0：基于神经网络的软件设计。真的很有前瞻性了。这进一步引出了当前正在迅速发展的 Agent Ecosystem。AutoGPT ，BabyAGI 和 HuggingGPT 这些项目形象生动地为我们展示了 LLM 的潜力除了在生成内容、故事、论文等方面，它还具有强大的通用问题解决能力。如果说 ChatGPT 本身的突破体现在人们意识到**语言可以成为一种服务**，成为人和机器之间最自然的沟通接口，这一轮新发展的关键在于人们意识到语言（不一定是自然语言，也包括命令、代码、错误信息）也是模型和自身、模型和模型以及模型和外部世界之间最自然的接口，让 AI agent 在思考和表达之外增加了调度、结果反馈和自我修正这些新的功能模块。于是**在人类用自然语言给 AI 定义任务目标（只有这一步在实质上需要人类参与）之后可以形成一个自动运行的循环**：
1. agent 通过语言思考，分解目标为子任务
2. agent 检讨自己的计划
3. agent 通过代码语言把子任务分配给别的模型，或者分配给第三方服务，或者分配给自己来执行
4. agent 观察执行的结果，根据结果思考下一步计划，回到循环开始

原生的 ChatGPT 让人和 AI 交流成为可能，相当于数学归纳法里 n=0 那一步。而新的 agent ecosystem 实现的是 AI 和自己或者其他 AI 或者外部世界交流，相当于数学归纳法里从 n 推出 n+1 那一步，于是新的维度被展开了。比如将机器人强大的机械控制能力和目前 GPT-4 的推理与多模态能力结合，也许科幻小说中的机器人将在不久成为现实。

## 业务场景

[关于大模型技术的三点思考](https://mp.weixin.qq.com/s/NMadeQkDdoIzJzqVUZOGlQ)企业日常经营就是在不断地做决策并执行。决策就是说企业处理一个事情的时候，比如营销、分发，有很多种不同的做法，要选择什么样的做法。但决策类 AI 明显不好做。因为决策，上游需要高质量的数据作为输入，下游的具体服务得靠人提供。
1. 先说下游执行服务的人。人的不确定性太多了，你出策略，即使 AI 做得再好，只是辅助，执行如果不到位，数字化也不会有进展。 执行，过去我们是人主要驱动的，即使有 CRM、ERP、HR，都是靠人，用非数字化的方式执行了之后，把结果一项一项填到系统里面去。
2. 上游输入的数据也是个大问题。数据怎么来呢？完蛋了，执行的过程绝大多数企业压根没收集到数据。这里的“数据”，不是说你没有历史数据，而是你今天正在开展的业务里边没有足够的反馈数据。什么是反馈数据？员工跟企业之间的数据交换其实有三条通道。
    1. 接受信息、接受培训，比如视频、文字、PPT；
    2. 人与人之间的交流，跟同事跟主管跟客户的交流；
    3. 是用系统。
3. 做决策，我们只能用系统里边的这些数据去产生策略，但在这三条路径当中，系统能占多少？系统可能 5% 都占不到， 95% 的时间你是在阅读，在跟人聊天，在写 PPT、填表格、开会，所以95% 的数据都不在系统里。**95%都是非结构化的、多模态的，我们没法抽象化、标准化，有的甚至都没法数据化**。这是数据的困境。
4. 为什么让机器下围棋这件事能搞定，但过去很多的决策 AI 却难以落地呢？因为现实环境太复杂，一些领域内没有像围棋软件这样的系统，比如销售，没有一个销售系统可以记录销售过程中的每一步。**但无论现实环境如何复杂，都可以转为一种对话式的沟通**，不管是供应链，还是营销。因为我们现在做的工作，就是通过一来一回的沟通解决。一定程度上，我们也可以把“一来一回沟通”这件事比作是数字化转型中的围棋软件。过去没有“围棋软件”，是因为系统没有一来一回沟通的能力，而且我们的**软件是固化的，围棋专家只知道下围棋的套路，不懂怎么下象棋**。各领域只有各自专用的大模型，得分别开发。现如今大模型的出现，意味着系统具备了一来一回沟通的能力，也就意味着有了围棋软件。而且，现如今的软件，相对来讲有流动性较强的、最普遍的基础——交互式对话，再加上 GPT 模型可以用语文的方式学习所有问题，企业就可以用一套软件，萃取不同行业不同员工的优秀经验，并且用沟通的方式，干预稍微差一些员工，让这个软件被所有人用起来。这意味着，生成式 AI 可以通过对话框的形式，实现机器与人的沟通，抓取到原来系统抓取不到的另外 95% 的数据，帮企业做更多数字化的事情，或者提高数字化转型的效率。核心区别就是，过去的执行是人为，而非数字化，即使有 CRM 或者 HR 这样的系统，**我们也只是将结果填入到系统而已**，就像两人下棋，我们只是将最后的输赢结果填入到系统中一样。但是在生成式 AI 出现后，通过巧妙的软件设计，可以将业务过程中每一步的数据都记录到系统中。当然，以前的也有可以记录每一步的软件，就像「滴滴出行」，但是由于资金、人员等各种限制条件，最终导致了行业软件化的进度缓慢。但有了大模型，这个进度就可以大大提升了。**过去我们说的信息化，多是指把所有的业务步骤抽象为表单和流程**。但是，抽象为表单和流程，不如抽象为对话加 Word 、PPT、或者 Excel。过去我们经常听到企业自嘲说自己的数字化特别落后，基本都是基于 Excel 在做。其实，这反而是一个比较经济的数字化方式，Excel 功能非常强大，是一种表格式的生成软件，只是很多人不会用，数据难以得到有效利用。现在，生成式的 AI，其实就是用对话的方式，加上一些多模态，**来标准化的生成软件，实现了从菜单式到对话式的交互进化**。PS： 一个模型一个task，一个工作一个软件（还只是负责了录入的部分），很多工作非标连软件都没有。
5. ChatGPT 让业界重拾了对 IM 机器人的重视，都认为对话框是数字化的最佳解法，这应该是轻物理资产、重人力要素的互联网企业的限定答案。在其他场景比如物流、驾驶、医疗中，人和机器的交互可能需要其他形式。医生做手术的时候能点对话框吗，不能，但他可以说话，这是一种交互状态；司机开车的时候能点对话框吗，也不能，但是可以用动作，这也是一种交互状态。所以 AIGC 这个事发展到未来，人和机器一定会是多模态的交互，而且是更接近于人的自然能力。IM 只是中间的一个过渡状态。从软件、表单过渡到 IM，中间从共享文档，变为对话框，再到未来的多模态拟人化交流，这个过程是愈发朝着“人”的角度发展的。我们看早期的输入法，在算力不足的情况下，我们必须要学习五笔字型，后来变为智能拼音、整句智能、语音转写，再到后来的直接语音，这条发展路径，是从人类被迫适应机器，到机器更加符合人性，我们可以跟软件、系统进行无障碍交流。
6. 过去我们常说，真正能够成功的 SaaS 系统非常难做。**SaaS 公司每天都面临着到底是定制化还是标准化的问题**。那我们能不能两者兼得呢？可以的——降低定制化成本，用标准化的成本完成定制化的需求。当然，**如果是按照传统表单式、流程式的软件，是无法达成的**，但 AIGC 可以：基于生成式的大模型，，将一部分需求转嫁给算力，一部分转嫁给企业自身对业务的理解，同时将中间部分做薄，进而逐步解决问题。

[KubeEye：Kubernetes 集群自动巡检工具](https://segmentfault.com/a/1190000039173086) 常规的巡检工具只能给一个错误event统计、按一定规则算个健康分 ==> [使用 ChatGPT 诊断 Kubernetes 问题 - K8sGPT](https://mp.weixin.qq.com/s/0xarxj49eM329o8xlSpmyg) 有了GPT 就可以更进一步怎么办（之前凭借工程师经验），再进一步，可以通过LangChain等工具排除直观一些的比如“版本不匹配”等错误原因。 
```
default_prompt = `Simplify the following Kubernetes error message delimited by triple dashes written in --- %s --- language; --- %s ---.
 Provide the most possible solution in a step by step style in no more than 280 characters. Write the output in the following format:
 Error: {Explain error here}
 Solution: {Step by step solution here}

 Error node3 has multiple conditions of type MemoryPressure,DiskPressure,PIDPressure and Ready with reason NodeStatusUnknown caused by Kubelet stopped posting node status. Solution:
 1. Restart kubelet service od node3.
 2. Check node3's connectivity with the control plane.
 3. Check if the kubelet version is compatile with the control plane version.
 4. Check for any issue with the underlying hardware.
```

[AI大模型如何在行业实际落地：企业对话场景拥抱大模型之路](AI大模型如何在行业实际落地：企业对话场景拥抱大模型之路)
1. 前几年，在数字化转型中，企业将一些简单的体力劳动、能总结出规律的活动，写成具体的程序，通过自动化校对的方式来实现。未来，情况可能会发生变化。大模型不但能够替代一些简单的体力劳动，还能替代一些简单的脑力劳动，甚至包括那些能够从日志里总结出经验的脑力劳动。
2. 之前，企业数字化主要针对企业内部的交易数据和核心业务系统，对这些数据通过数据挖掘的方法进行建模，实现降本增效。随着近些年大模型的高速发展，对话数据成为企业愈发重视的数据资源。无论在现阶段还是未来，无论是企业与外部客户沟通还是企业内部员工的培训和协作，对话都一直是最主要、最自然的交互形式。在这期间，会产生很多对话数据，包括线下营销和线上营销、文字沟通和电话沟通等场景。过去，**企业的数据只是存了下来，并没有进行结构化的表示和挖掘**，更遑论理解这些非结构化数据中蕴含的语义，提取出智能服务。企业希望充分利用对话数据、挖掘对话数据的价值，从而更好地服务于数字化的需求。比如通过电子工牌或呼叫中心将销售过程录下来，采用 ASR 语音转写技术将录音转成文本；再通过对话文本挖掘出用户的意图；随着对话过程不断进行，大模型可以实时生成流程图谱，给销售提供对话建议，分析潜在的话题引导方向，提升销售人员的营销技能，提高成单概率和用户的留存率。

[大模型“吞噬”应用和生态](https://zhuanlan.zhihu.com/p/631250773 )
1. 简单的应用，比如提供数据源(日历)和弱控制（家电控制），会被大模型系统聚合，这些应用蜕变成一个Plugin接入到这个大模型系统中，成为南向，而大模型系统则变成了一个超级应用，为所有这些plugin提供自然交互和控制能力，典型的例子是ChatGPT Plugin体系。
2. 复杂的应用，则会被重构，演进到AI Native的架构，特点就是与大模型结合，使用大模型系统提供的SDK，实现全新的交互、控制和认知能力，成为大模型系统的北向，比如微软 365加持copilot，为365提供：
    1. 内容生成—释放创造力，word/ppt/excel等内容生成，帮你写草稿；
    2. 推理和归纳—释放生产力，自动执行任务/内容总结/自动回复邮件等；
    3. 提升技能：原来90%没有被大家普遍使用的功能和特性，都逐步被挖掘出来，比如在Excel中大量的公式，以前需要熟手才能使用，现在通过自然语言的交互和理解，就可以轻松使用。

![](/public/upload/machine/llm_ecology.jpg)

[从原理到应用，人人都懂的ChatGPT指南](https://mp.weixin.qq.com/s/vTJkGHrTIhKNx79m6WLmhQ)按照感知其能力的直观性
1. **聊天即交付**（Chat to Delivery(C2D)）。聊天能力，GPT的回答就是给客户的交付物，是GPT模型最简单、最直观的用法。
    1. 套壳聊天机器人
    2. 场景化问答。 对GPT的回复场景进行了约束。通过限定提示词、嵌入大量特定领域知识以及微调技术，使GPT能够仅基于某类身份回答特定类型的问题。对于其他类型的问题，机器人会告知用户不了解相关内容。
2. 语言能力。需要使用one-shot或few-shot（在提示词中给ChatGPT一个或多个示例）来提升ChatGPT的表现。与用户的交互不再局限于聊天窗口，提前预制**提示词模板**，用户只能输入限定的信息，对应提示词的空槽位。将用户输入 放入预制好提示词模版的指定槽位，传给GPT。
    ![](/public/upload/machine/llm_prompt_template.jpg)
3. 文本能力，使用few-shot技巧，能解决训练数据中不存在的问题。
4. 推理能力，用ChatGPT理解人类意图的能力，以GPT的推理能力替代手动点击操作流，将带来B端和C端的产品设计的颠覆式变化。

企业会根据三大能力衍生出三大类角色：
1. 问题分解者，这类角色很清楚大语言模型能力的边界，能够将一个业务问题有效的分解为GPT能处理的子问题，并能根据问题结果，将子问题进行拼装。
2. 提示工程师，这类角色深谙与GPT沟通之道，能够根据不同的问题类型，给出有效的提示词模板，极大提升GPT的输出质量。
3. 知识拥有者，这类角色有大量的行业knowhow，并且能够将知识进行结构化，传授给GPT。对应现在的领域专家。

![](/public/upload/machine/llm_role.jpg)

基于某个规则让大模型帮忙筛选简历。一些简历pdf，从中提取特定信息，组成json 返回。再进一步，可以提出自己的需求，让大模型筛选出最接近满足需求的。

[通过大语言模型（LLM）识别与修复风险代码](https://mp.weixin.qq.com/s/JfEEJQyv9pdFB0-mBKC6UA)

[大模型在知乎舰桥平台的应用和实践](https://mp.weixin.qq.com/s/8J-aBVem4RTMpZCcyxL0ww)

## 技术实现 

[LLMOps的现在与将来](https://mp.weixin.qq.com/s/gr1zom0j361R5h9dDU84YA) 使用LLMs制作一些很酷的东西很容易，但是很难使它们成为生产型的。LLMOps是针对LLM的MLOps，**我们的重点不是从头开始训练LLM，而是适应预训练的LLM用于下游任务**。这涉及选择基础模型、在下游任务中使用LLM、评估它们以及部署和监视模型。
1. 选择基础模型。主流是Decoder-Only,但Encoder-Decoder仍有前景。如何挑选基座模型：模型的效果，推理速度，context大小、价格开销，能否微调，数据安全，许可协议等。
2. 适应下游任务。 主要挑战在于，尽管LLM很强大，但它们并非万能的，因此关键问题是：如何使LLM给出您想要的输出？
    1. Prompt Engineering，是一种调整输入以使输出与您的期望相匹配的技术，已经出现了像LangChain或HoneyHive的工具，帮助您管理和版本化提示模板。guardrails/guidance封装了输出的结构化检查和修复（如果不符合格式，生成相关错误信息，将上一次的生成内容和检查的错误信息告知 LLM，进行下一次的修正生成，直到生成的内容完全符合我们的要求）。
        1. [构建高性能 Prompt 之路——结构化 Prompt](https://zhuanlan.zhihu.com/p/647134737) 
        2. https://github.com/dair-ai/Prompt-Engineering-Guide 
    2. Fine-tuning pre-trained models，可以帮助改善模型在特定任务上的性能。虽然这将增加训练工作量，但它可以减少推理成本。**LLM API的成本取决于输入和输出序列长度**，因此，减少输入标记的数量可以减少API成本，因为不再需要在提示中提供示例。 一般来说优先选择前者， 尤其是当前开源模型，fine tune 技术都没有那么成熟的情况下。什么时候需要 fine tune 呢？
        1. 你需要节省成本，比如用更小的模型，不想每次都带一大段 prompt 之类。
        2. 你有大量的数据，且 retrieval 的方法表现不够理想。
        3. LoRA 与 QLoRA 训练技术 https://github.com/microsoft/LoRA 。对预训练好的大模型参数进行冻结，也就是在微调训练的时候，这些模型的参数设置为不可训练。然后往模型中加入额外的网络层，并只训练这些新增的网络层参数。这样可训练的参数就会变的非常少，可以以低成本的 GPU 微调大语言模型。LoRA 在 Transformer 架构的每一层注入可训练的秩分解矩阵，与使用 Adam 微调的 GPT-3 175B 相比，LoRA 可以将可训练参数数量减少 10000 倍，GPU 内存需求减少 3 倍，并且在效果上相比于传统微调技术表现的相当或更好。[huggingface/peft](https://github.com/huggingface/peft)
        4. 所谓后训练量化是指在模型训练完成之后进行量化，模型的权重会从 32 位浮点数（或其他较高精度格式）转换为较低精度格式，例如 4 位整数。这种转换大大减小了模型的大小，并减少了运行模型所需的计算量。但是，这也可能会导致一定程度的精度损失。 GPTQ（Generative Pretrained Transformer Quantization）是一种新的后训练量化方法，可以有效地执行对有数百亿参数的模型的量化，并且能够将这些模型压缩到每个参数 3 或 4 位，而不会有显著的精度损失。
    3. 外部数据，已经有一些工具可用，例如LlamaIndex（GPT Index）、LangChain或DUST，可以作为中央接口连接（“chaining”）LLM和其他代理和外部数据。
    4. 嵌入/embedding，从LLM API中提取嵌入形式的信息，（例如，电影摘要或产品描述），并在其上构建应用程序（例如，搜索、比较或推荐）。如果 np.array 不足以用于长期存储您的嵌入，可以使用向量数据库，如Pinecone、Weaviate或Milvus。PS：LLM加向量数据库这个范式，很像一个硬盘巨大但内存很小的电脑。随着LLM 支持更长的context，向量数据库可能会过时。
3. 评估，如何评估LLM的性能？如何确定响应是好还是坏？LLM 的能力非常强大，能处理各种任务，这对其评估造成了很大的困难，比如我们很难判断一篇总结是否比另外一篇总结写得更好。对于不同的 prompt，模型甚至 fine tune 的效果，如何进行快速，低成本且准确的评估是一个大问题。目前，似乎组织正在对其模型进行A/B测试。为了帮助评估LLM，出现了像HoneyHive或HumanLoop这样的工具。PS：一个办法是做好业务与大模型交互的抽象，没事按大模型榜单多换换，看看效果。
    1. https://github.com/PKU-YuanGroup/ChatLaw 如何合理地评估垂直领域大模型的性能一直是一个问题，因为测试数据和真实场景存在差异，我们暂时没有完美的思路。我们只是收集了十余年的国家司法考试题目，整理出了一个包含2000个问题及其标准答案的测试数据集，用以衡量模型处理法律选择题的能力。
4. 部署和监控，例如，OpenAI已经更新了其模型以减轻不当内容的生成，例如仇恨言论。目前已经出现了一些监控LLM的工具，如Whylabs或HumanLoop。

![](/public/upload/machine/llmops_workflow.jpg)

假设一个场景，我希望chatgpt是个咨询专家，他可以回答我的一些问题。我问chatgpt一些问题，它会基于外部数据库和自身的能力给我回复。
这里会有两个问题需要考虑：
1. 提问的技巧，就是现在人们在热烈讨论的prompt engineer，是一种调整输入以使输出与您的期望相匹配的技术。PS：**有点像 RHLF之后的二次对齐**
2. 如何利用外部知识，LLM通常缺乏上下文信息（例如，无法访问某些特定文档或电子邮件）并且可能很快过时，因为LLM如果没有足够的信息会产生幻觉，所以我们需要能够给它们提供相关的外部数据。

![](/public/upload/machine/use_llm.jpg)

由于LLM生成结果的不确定性和不准确性，目前还无法仅依靠LLM提供智能化服务。**构建GPT应用远远不是调用API**。PS：就像操作linux 远远不止调用系统调用，有很多工程问题/发挥空间。 
1. 它的“脑子”也不完美，OpenAI 的训练数据截止至 2021 年，并且没有任何企业和个人的私有数据，这让模型只能根据自己的“记忆”回答问题，并且经常给出与事实相悖的答案。一个解决方法是在 Prompt 中将知识告诉模型，但是这往往受限于 token 数量，在 GPT-4 之前一般是 4000 个字的限制。
2. 它只有“脑子”没有“手臂”，无法在外部世界行动，不论是搜索网页、调用 API 还是查找数据库，这些能力都无法被OpenAI的 API 提供；说白了只使用openAI不是商业应用，不能产品化。

### 引入外部知识 的几个示例

大语言模型的原理，就是利用训练样本里面出现的文本的前后关系，通过前面的文本对接下来出现的文本进行概率预测。如果类似的前后文本出现得越多，那么这个概率在训练过程里会收敛到少数正确答案上，回答就准确。如果这样的文本很少，那么训练过程里就会有一定的随机性，对应的答案就容易似是而非。

LLM 擅长于一般的语言理解与推理，而不是某个具体的知识点。如何为ChatGPT/LLM大语言模型添加额外知识？
1. 通过fine-tuning来和新知识及私有数据进行对话，OpenAI 模型微调的过程，并不复杂。你只需要把数据提供给 OpenAI 就好了，对应的整个微调的过程是在云端的“黑盒子”里进行的。需要提供的数据格式是一个文本文件，每一行都是一个 Prompt，以及对应这个 Prompt 的 Completion 接口会生成的内容。
    ```
    {"prompt": "<prompt text>", "completion": "<ideal generated text>"}
    {"prompt": "<prompt text>", "completion": "<ideal generated text>"}
    {"prompt": "<prompt text>", "completion": "<ideal generated text>"}
    ...
    ```
    有了准备好的数据，我们只要再通过 subprocess 调用 OpenAI 的命令行工具，来提交微调的指令就可以了。
    ```
    subprocess.run('openai api fine_tunes.create --training_file data/prepared_data_prepared.jsonl --model curie --suffix "ultraman"'.split())
    ```
    微调模型还有一个能力，不断收集新的数据，不断在前一个微调模型的基础之上继续微调我们的模型。
2. 通过word embeddings + pinecone数据库来搭建自己私有知识库。 chatgpt预训练完成后，会生成一个embeddings向量字典，比如我们可以将我们的私有知识库各个章节通过openai的相关api获取到对应的embeddings，然后将这些embeddings保存到向量数据库（比如 Facebook 开源的 Faiss库、Pinecone 和 Weaviate），当用户要对某个领域后者问题进行语义查询时，则将用户的输入同样通过openai的相关api来获取相应的embeddings向量，然后再和向量数据库pinecone中的我们的私有知识库类型做**语义相似度查询**，然后返回给用户。PS： 内容向量化
    1. 比如判断某一段文本 是积极还是消极，向chatgpt 查询目标文本的向量，然后计算其与“积极” “消极” 两个词 embedding 向量的“距离”，谁更近，说明这段文本更偏向于积极或消极。
    2. 过几天openAI的模型版本升级了，这些保存的embedding会失效吗？特定模型也有带日期的快照版本，选取那些快照版本就好了。
    3. 向量是基于大模型生成的，因此对两段文本向量相似度计算必须基于同一个模型，不同的模型算出来的向量之间是没有任何关系的，甚至连维数都不一样。不过你可以把基于A 模型来算向量相似度进行检索把文本找出来，然后把找到的文本喂给B模型来回答问题。 
3. 通过langchain这个chatgpt编程框架来给chatgpt赋能。 langchain可以将不同的工具模块和chatgpt给链接（chain）起来。
4. chatgpt 插件，比如有一个提供酒旅租车信息的插件
    ![](/public/upload/machine/chatgpt_plugins.jpg)

比如针对问题：鲁迅先生去日本学习医学的老师是谁。因为 LLM（大语言模型）对上下文长度的限制，你不能将《藤野先生》整体作为提示语然后问“鲁迅在日本的医学老师是谁？”。 先通过搜索的方式，找到和询问的问题最相关的语料。可以用传统的基于关键词搜索的技术。也可以先分块存到向量数据库中（向量和文本块之间的关系），使用 Embedding 的相似度进行语义搜索的技术。然后，我们将和问题语义最接近的前几条内容，作为提示语的一部分给到 AI（**使用检索结果作为 LLM 的 Prompt**）。然后请 AI 参考这些内容，再来回答这个问题。

![](/public/upload/machine/use_llm_with_search.jpg)
![](/public/upload/machine/llm_with_embedding.jpg)

这也是利用大语言模型的一个常见模式（这个模式实在太过常用了，所以有人为它写了一个开源 Python 包，叫做 llama-index）。因为**大语言模型其实内含了两种能力**。PS：有点像推荐的粗排和精排，纯向量化的召回在一些Benchmark上表现还不如关键字搜索。
1. 海量的语料中，本身已经包含了的知识信息。比如，我们前面问 AI 鱼香肉丝的做法，它能回答上来就是因为语料里已经有了充足的相关知识。我们一般称之为“世界知识”。
2. 根据你输入的内容，理解和推理的能力。这个能力，不需要训练语料里有一样的内容。而是大语言模型本身有“思维能力”，能够进行阅读理解。这个过程里，“知识”不是模型本身提供的，而是我们找出来，临时提供给模型的。如果不提供这个上下文，再问一次模型相同的问题，它还是答不上来的。

**Embedding 生成向量使用的模型  跟最后prompt 调用的模型可以不是同一个**，因此有的向量数据库也包含Segment 和 Embedding，**通过自然语言就能直接和向量数据库交互**。也就是说，我们可以直接把文档扔给数据库，大段文本的切分，以及文本向量化，向量数据库 会帮我们处理。我们也可以直接把问题扔给数据库，请他来查询相似度较高的文本块，问题向量化以及检索的细节，向量数据库会帮我们处理。

[基于大语言模型构建知识问答系统](https://zhuanlan.zhihu.com/p/627655485) 
1. 传统搜索系统基于关键字匹配，在面向：游戏攻略、技术图谱、知识库等业务场景时，缺少对用户问题理解和答案二次处理能力。
2. 领域知识不在预训练的数据集中，比如：
    1. 较新的内容。同一个知识点不断变更：修改、删除、添加。如何反馈当前最新的最全面的知识。比如对于 ChatGpt 而言，训练数据全部来自于 2021.09 之前。
    2. 未公开的、未联网的内容。
3. 基于 LLM 搭建问答系统的解决方案有以下几种：
    1. Fine-Tuning
    2. 基于 Prompt Engineering，比如 Few-Shot方式。**将特定领域的知识作为输入消息提供给模型**。类似于短期记忆，容量有限但是清晰。举个例子给 ChatGPT 发送请求，将特定的知识放在请求中，让 ChatGPT 对消息中蕴含的知识进行分析，并返回处理结果。
    3. 与普通搜索结合，使用基础模型对搜索结果加工。在做问答时的方式就是把 query 转换成向量，然后在文档向量库中做相似度搜索。
        ![](/public/upload/machine/llm_with_knowledge_base.jpg)
    4. 用户输入query之后，首先先从知识库搜索到结果，然后基于搜索到的结果进行解析构造，生成新的prompt，然后调用LLM，LLM根据输入的prompt自行进行知识库的检索与plugins的调用
        ![](/public/upload/machine/use_llm_with_prompt.jpg)

**LLM 距离 AGI 的一大差距是没法与真实世界连接**。[LLM 应用开发全栈指南](https://mp.weixin.qq.com/s/weH_7K2g3sBMbtei1_dTng)以 SQL 工具为例展示了下 LLM 如何来利用外部工具。**根据自然语言生成SQL语句**（Text2SQL）大致为以下几个步骤：
1. 用户问了一个问题
2. 将用户问题和数据库的 meta 信息放到 prompt 里，让 LLM 去生成 SQL
3. 利用数据库来执行这个 SQL 查询，这就是工具的调用
4. 将数据库查询结果与问题再扔给 LLM 做最终回答

当然这个步骤可以说是由 Chain 定义固定下来的，也可以采用类似 agent/plugin 的方式来让 LLM 自行决定在何时使用什么工具。用户只需要提供 API 的 spec 和描述，就可以快速接入到 plugin 体系中。这两种方式主要的权衡在于可靠性或者是流程的确定程度。Chain 的运作流程是人工定义好的，流程不会出错，且对 LLM 来说生成具体的工具指令也会准确率更高。而 plugin 的优势在于极大的流程灵活度，可以用统一入口满足用户各类诉求。虽然可靠性会下降不少，但也可以考虑引入人工交互来弥补。

LangChain实时推荐天气
1. 通过一个 HTTP 请求，根据搜索词拿到 Google 的搜索结果页。
2. 把我们定义的 Prompt 提交给 OpenAI，然后把我们搜索的问题和结果页都发给了 OpenAI，让它从里面提取出搜索结果页里面的天气信息。
3. 最后我们通过 transform_func 解析拿到的天气信息的文本，被转换成一个 dict。这样，后面的程序就好处理了。


## 是否自建大模型

[自建行业大模型的思考](https://zhuanlan.zhihu.com/p/625186095)是否需要构建行业大模型？
1. 通用 LLM会不会大力出奇迹，在没有经过专业领域数据训练的条件下就可以很好的完成专业领域任务？BloombergGPT的论文中实现表明：基于专业领域语料训练的大模型，在领域内的理解要超过通用大模型；
2. 能否通过为Prompt填充领域知识的方式，让LLM具备解决专业领域任务的能力？可以，角色扮演就是一个例子
    1. 优点：灵活多变，可以适应各种场景，几乎没有训练成本，所有的行业知识通过prompt注入
    2. 缺点：大量领域知识会限制多轮对话或者prompt构造，模型输入有长度限制，如果加入了较多领域知识，就没有空间留给理会对话以及prompt；对于专业词汇的理解可能不准确
3.  能否通过检索的方式，从本地知识库中查找出符合要求的答案返回？可以，例如：插件、AutoGPT
    1. 优点：没有训练成本；返回结果完全可控，即知识库内容
    2. 缺点：大模型+检索的方式分成两步走，性能会较慢；回答内容单一，缺乏泛化性；对于专业词汇的理解可能不准确

自建 or 购买
1. 购买。
    1. 数据安全风险；比如使用 ChatCompletion 的接口，需要传入大量的上下文信息。
    2. 缺乏商业护城河；
    3. 不够灵活：新的需求和模型效果提升可能需要重新签订协议购买
2. 自建。训练成本较高：数据成本、算力成本、试错成本；模型效果难以保证；对于模型训练算法工程师有较高要求

自建大语言模型可能遇到的问题
1. 容易解决的问题
    1. 模型训练方案容易实现，现阶段开源LLM都有完善的训练和推理流程；
    2. 效果优异的基座模型，虽然中文开源LLM效果还没有英文的那么多、那么好，但是也已经达到了够用的水平；
2. 不容易解决的问题
    1. 明确的LLM需求
        1. 高级收益需求：某个功能以前无法实现，LLM可以助力实现，并为公司带来较高收益；
        2. 次级收益需求：某个已经实现的功能，LLM可以对其优化，降本增效；
    2. 训练数据难以构建，训练数据应该具备一下特征：训练大模型需要巨量数据；涵盖多种问题，同一问题还应该有多种表达方式；数据应该尽量准确，不能含有有毒数据；要包含大量通用文本语料，在二次训练过程中会有灾难性遗忘问题，需要通用语料保持LLM通用语言能力；要包含本公司业务领域的文本语料，提升LLM对于行业数据理解能力；最好包含多轮对话语料，使模型具备连续对话的能力；最好能有同一个问题的不同得分的回答，实现RLHF的训练
    3. 部署成本高昂：
        1. LLM模型参数量巨大，一般自建模型参数量最小是7B，需要占用大量显存；
        2. 即使使用量化技术，推理服务QPS也不会很高；[字节跳动提出高性能 transformer 推理库，获 IPDPS 2023 最佳论文奖](https://mp.weixin.qq.com/s/HSJDNdgtFlaW16x2430m9g) 针对自然语言处理常见的可变长输入，论文提出了一套优化算法，这些算法在保证运算正确性的前提下，成功避免了传统实现中的冗余运算，实现了端到端的推理过程的大幅优化。
        3. 使用量化技术会让模型虽然会提升性能，降低显存占用，但是会极大损害效果；
        4. 较长的sequence length会占用大量的显存，增加计算消耗（时间复杂度是sequence length的平方）；
        5. 高性能GPU服务器成本较高
    4. 大语言模型生成结果不可控：生成模型普遍存在生成结果不可控的问题；需要尝试不同的prompt才能得到令人满意的结果。


## 用好大模型

为了让 LLM 能够回答那些它最初未接受训练的内容，**用好大模型的第一个层次，是掌握提示词工程(Prompt Engineering)，用好大模型的第二个层次，是大模型的微调(Fine Tuning)**。

[大模型研发核心：数据工程、自动化评估及与知识图谱的结合](https://mp.weixin.qq.com/s/SvDnQD886E3DBtw8k9asgg) 值得细读

### Prompt Engineering

为模型增加外部记忆，在提示词中引入一些领域知识，帮助模型提升回答质量。

[人人都需要掌握的Prompt Engineering技巧](https://mp.weixin.qq.com/s/JvoBOzdHmagLXiT2k1nYPQ)对于一些复杂的问题，Prompt写得好不好，直接影响着大模型给出答案的正确与否。本质上，**LLM是一个概率模型，它只是在给定的信息的前提下，给出概率最大的结果，它并不保证结果的合理性和正确性**。要让LLM给出的结果尽可能地合理、正确，这是我们使用LLM的人的职责。

AI界的大佬 --- Andrew NG推出过一个Prompt Engineering的短课程《ChatGPT Prompt Engineering for Developers》，提到写好Prompt的一些基本理念。
1. 明确、具体是关键。我们发给LLM的批令，越明确、越具体，对于LLM越友好。
2. 给LLM更多的时间去思考。通过Prompt Engineering 的方式，把LLM的“慢思考”调动起来。
    1. 一个简单的技巧是在你的Prompt后面，加上这样一句话“Let’s think step by step”。这句话会引导LLM，会去分步骤思考，效果会比不加这句话要好。
    2. CoT(Chain-of-Thought) 在Prompt中加入一些例子，让LLM照着例子进行推理、思考。注意，CoT是LLM足够大（参数足够多，通常是在1000亿参数）时才涌现出来的能力。因此，在一些不够大的LLM上，CoT的效果并不明显。此外，在Prompt中加入的示例不是1条，而是多条。具体要考虑解决的问题类型，以及Prompt的长度（因为LLM的Prompt长度通常都是有长度限制的）。
3. Self-Consistency技术：利用CoT Prompting技巧，写好Prompt；不要让LLM只生成最合适的唯一一个结果，而是利用LLM结果的多样性，生成多种不同推理路径所得的结果的集合；从结果集合中投票选择，选出投票最多的结果，做为最终的答案。
4. 从易至难技术：Least-to-Most，CoT的特点是同类型问题的迁移思考，因此，如果给的例子是比较简单的问题，而给的问题却是难度大很多的问题，这时候CoT的效果就不尽如人意。LtM(Least-to-Most)主是为了解决CoT这种从易到难的迁移能力不足而诞生的。LtM的核心思想是：教LLM把复杂问题，拆解成一系列的简单问题，通过解决这一系列的简单问题，来最终得到复杂问题的结果。LtM的过程包含两个阶段：
    1. 分解阶段：把复杂问题分解成一系列的简单子问题。这个阶段的Prompt中要包含分解问题的示例，要和分解的问题；
    2. 解决子问题阶段：这个阶段的Prompt中包含三部分内容：一是完整的LtM的例子；二是已解决的子问题及其答案列表；三是接下来要解答的子问题。

### 微调大模型

[通俗解读大模型微调(Fine Tuning)](https://mp.weixin.qq.com/s/PXTAhvUGzvOPLdBYNWb3xw)Prompt Engineering的方式是一种相对来说容易上手的使用大模型的方式，但是它的缺点也非常明显。
1. 因为通常大模型的实现原理，都会对输入序列的长度有限制，Prompt Engineering 的方式会把Prompt搞得很长。越长的Prompt，大模型的推理成本越高，因为推理成本是跟Prompt长度的平方正向相关的。
2. Prompt太长会因超过限制而被截断，进而导致大模型的输出质量打折口，这也是一个非常严重的问题。
3. Prompt Engineering的效果达不到要求时，企业又有比较好的自有数据，能够通过自有数据，更好的提升大模型在特定领域的能力。这时候微调就非常适用。
4. 要在个性化的服务中使用大模型的能力，这时候针对每个用户的数据，训练一个轻量级的微调模型，就是一个不错的方案。
5. 数据安全的问题。如果数据是不能传递给第三方大模型服务的，那么搭建自己的大模型就非常必要。通常这些开源的大模型都是需要用自有数据进行微调，才能够满足业务的需求，这时候也需要对大模型进行微调。

如何对大模型进行微调
1. 对全量的参数，进行全量的训练，这条路径叫全量微调FFT(Full Fine Tuning)。但FFT也会带来一些问题，影响比较大的问题，主要有以下两个：一个是训练的成本会比较高，因为微调的参数量跟预训练的是一样的多的；一个是叫灾难性遗忘(Catastrophic Forgetting)，用特定训练数据去微调可能会把这个领域的表现变好，但也可能会把原来表现好的别的领域的能力变差。
2. 只对部分的参数进行训练，这条路径叫PEFT(Parameter-Efficient Fine Tuning)。有以下几条技术路线：
    1. 一个是监督式微调SFT(Supervised Fine Tuning) ，这个方案主要是用人工标注的数据，用传统机器学习中监督学习的方法，对大模型进行微调；
    2. 一个是基于人类反馈的强化学习微调RLHF(Reinforcement Learning with Human Feedback) ，这个方案的主要特点是把人类的反馈，通过强化学习的方式，引入到对大模型的微调中去，让大模型生成的结果，更加符合人类的一些期望；
    3. 还有一个是基于AI反馈的强化学习微调RLAIF(Reinforcement Learning with AI Feedback) ，这个原理大致跟RLHF类似，但是反馈的来源是AI。这里是想解决反馈系统的效率问题，因为收集人类反馈，相对来说成本会比较高、效率比较低。

一些比较流行的PEFT方案
1. Prompt Tuning，Prompt Tuning的出发点，是基座模型(Foundation Model)的参数不变，为每个特定任务，训练一个少量参数的小模型，在具体执行特定任务的时候按需调用。Prompt Tuning的基本原理是在输入序列X之前，增加一些特定长度的特殊Token，以增大生成期望序列的概率。具体来说，就是将$X = [x1, x2, ..., xm]变成，X` = [x`1, x`2, ..., x`k; x1, x2, ..., xm], Y = WX`$。如果将大模型比做一个函数：Y=f(X)，那么Prompt Tuning就是在保证函数本身不变的前提下，在X前面加上了一些特定的内容，而这些内容可以影响X生成期望中Y的概率。
2. Prefix Tuning，Prefix Tuning的出发点，跟Prompt Tuning的是类似的，只不过它们的具体实现上有一些差异。Prompt Tuning是在Embedding环节，往输入序列X前面加特定的Token。而Prefix Tuning是在Transformer的Encoder和Decoder的网络中都加了一些特定的前缀。具体来说，就是将Y=WX中的W，变成$W` = [Wp; W]，Y=W`X$。Prefix Tuning也保证了基座模型本身是没有变的，只是在推理的过程中，按需要在W前面拼接一些参数。
3. LoRA，LoRA背后有一个假设：我们现在看到的这些大语言模型，它们都是被过度参数化的。而过度参数化的大模型背后，都有一个低维的本质模型。通俗讲人话：大模型参数很多，但并不是所有的参数都是发挥同样作用的；大模型中有其中一部分参数，是非常重要的，是影响大模型生成结果的关键参数，这部分关键参数就是上面提到的低维的本质模型。LoRA的基本思路，在原始预训练模型旁边增加一个旁路，先用一个 Linear 层 A，将数据从 d 维降到 r 维，在用第二个 Linear 层 B，将数据从 r 维变回 d 维。LoRA 训练的时候固定预训练模型的参数，只训练降维矩阵 A 和升维矩阵 B。包括以下几步：
    1. 要适配特定的下游任务，要训练一个特定的模型，将Y=WX变成$Y=(W+∆W)X$，这里面$∆W$主是我们要微调得到的结果；
    2. 将∆W进行低维分解`∆W=AB` (`∆W`为m * n维，A为m * r维，B为r * n维，r就是上述假设中的低维)；
    3. 接下来，用特定的训练数据，训练出A和B即可得到∆W，在推理的过程中直接将∆W加到W上去，再没有额外的成本。另外，如果要用LoRA适配不同的场景，切换也非常方便，做简单的矩阵加法即可：$(W + ∆W) - ∆W + ∆W`$。
    ![](/public/upload/machine/lora.jpg)
4. QLoRA，QLoRA就是量化版的LoRA，量化，是一种在保证模型效果基本不降低的前提下，通过降低参数的精度，来减少模型对于计算资源的需求的方法。量化的核心目标是降成本，降训练成本，特别是降后期的推理成本。

结合代码
1. 加载数据集，pytorch Dataset/DataLoader
2. 构建模型，在实际操作中，除了使用预训练模型编码文本外，我们通常还会进行许多自定义操作，因此在大部分情况下我们都需要自己编写模型，不过不用从0写，更为常见的写法是继承 Transformers 库中的预训练模型来创建自己的模型。
    ```python
    class BertForPairwiseCLS(BertPreTrainedModel):     # 继承 BERT 模型（BertPreTrainedModel 类）
        def __init__(self, config):
            super().__init__(config)
            self.bert = BertModel(config, add_pooling_layer=False)
            self.dropout = nn.Dropout(config.hidden_dropout_prob)
            self.classifier = nn.Linear(768, 2)
            self.post_init()
        
        def forward(self, x):
            bert_output = self.bert(**x)
            cls_vectors = bert_output.last_hidden_state[:, 0, :]
            cls_vectors = self.dropout(cls_vectors)
            logits = self.classifier(cls_vectors)
            return logits
    config = AutoConfig.from_pretrained(checkpoint) # 通过预置的 from_pretrained 函数来加载模型参数
    model = BertForPairwiseCLS.from_pretrained(checkpoint, config=config).to(device) # 加载 预置模型
    print(model)
    # Transformers 库同样实现了很多的优化器，相比 Pytorch 固定学习率，Transformers 库的优化器会随着训练过程逐步减小学习率（通常会产生更好的效果）
    optimizer = AdamW(model.parameters(), lr=learning_rate)
    def train_loop(dataloader, model, loss_fn, optimizer,...): ...
    def test_loop(dataloader, model, mode='Test'): ...
    for t in range(epoch_num):
        total_loss = train_loop(train_dataloader, model, loss_fn, optimizer, lr_scheduler, t+1, total_loss)
        valid_acc = test_loop(valid_dataloader, model, mode='Valid')
        if valid_acc > best_acc:
            best_acc = valid_acc
            print('saving new weights...\n')
            torch.save(model.state_dict(), ...) #     # 保存模型
    ```


### AutoGPT

与Chains依赖人脑思考并固化推理过程的做法不同，AutoGPT是一个基于GPT-4语言模型的、实验性的开源应用程序，**可以根据用户给定的目标，自动生成所需的提示**，并执行多步骤的项目，无需人类的干预和指导（自己给自己提示）。AutoGPT的本质是一个自主的AI代理，可以利用互联网、记忆、文件等资源，来实现各种类型和领域的任务。这意味着它可以扫描互联网或执行用户计算机能够执行的任何命令，然后将其返回给GPT-4，以判断它是否正确以及接下来要做什么。下面举一个简单的例子，来说明AutoGPT的运行流程。假设我们想让AutoGPT帮我们写一篇关于太空的文章，我们可以给它这样的一个目标：“写一篇关于太空的文章”。然后AutoGPT会开始运行，它会这样做：

1. AutoGPT会先在PINECONE里面查找有没有已经写好的关于太空的文章，如果有，它就会直接把文章展示给我们，如果没有，它就会继续下一步。
2. AutoGPT会用GPT-4来生成一个提示，比如说：“太空是什么？”，然后用GPT-4来回答这个提示，比如说：“太空是指地球大气层之外的空间，它包含了许多星球，卫星，彗星，小行星等天体。”
3. AutoGPT会把生成的提示和回答都存储在PINECONE里面，并且用它们来作为文章的第一段。
4. AutoGPT会继续用GPT-4来生成新的提示，比如说：“太空有什么特点？”，然后用GPT-4来回答这个提示，比如说：“太空有很多特点，比如说，太空没有空气，没有重力，没有声音，温度变化很大等等。”
5. AutoGPT会把生成的提示和回答都存储在PINECONE里面，并且用它们来作为文章的第二段。
6. AutoGPT会重复这个过程，直到它觉得文章已经足够长或者足够完整了，或者达到了一定的字数限制或者时间限制。
7. AutoGPT会把最终生成的文章展示给我们，并且询问我们是否满意。如果我们满意，它就会结束运行；如果我们不满意，它就会根据我们的反馈来修改或者补充文章。

[探索AI时代的应用工程化架构演进，一人公司时代还有多远？](https://mp.weixin.qq.com/s/xgdMbYv__YNKFJ2n7yMDBQ)在冯诺依曼架构或者哈佛架构设备的实际开发中，我们会去关心如何使用相应协议去寻址去读写总线操作不同设备，如UART、I2C、SPI总线协议，这都是我们要学习掌握的，但我们基本不会关心CPU中的CU、ALU等单元。计算机架构这样求同存异的继续发展下去，将这些单元与高速存储及总线等作为抽象概念去进一步封装。而AI应用也是类似的，Agent会将相关的规划反思改进能力不断的作为自身的核心能力封装。因此，对于未来的AI应用极有可能不是在传统计算机上运行的程序，而是标准化的需求，在以规划能力专精的Agent 大模型作为CPU的AI计算机虚拟实例上直接运行的，而我们今天所谈论的应用架构，也会沉积到底层转变为AI计算机的核心架构。最终AI计算机将图灵完备，通过AI的自举将迭代产物从工程领域提升到工业领域。

![](/public/upload/machine/llm_agent.jpg)

## LLMOps

钱，算力，数据哪个会成为大模型继续 scale 的瓶颈？总体来说最有可能成为瓶颈的是数据。在特定数据量下即使是无限的参数量都没法打败拥有更多数据量训练出来的有限参数量的模型。因为 retrieval 模式非常有效，所以大家自然会有想法说是不是不需要那么大的模型来记住各种知识点，而只需要一个拥有推理能力的小模型就可以？小模型可以在手机端，机器人设备上直接部署使用，想象空间还是非常大的。

我们的重点不是从头开始训练LLM，而是适应预训练的LLM用于下游任务。

![](/public/upload/machine/mlops_vs_llmops.jpg)

1. LangChain 的链式调用方法或者说编程语言 Python 不适合生产环境，真正工业级的应用需要有离线、近线几套系统配合供给，才能让在线系统效果出众、性能稳定。
2. 大模型通过提示词中信息的 Embedding 去检索外部记忆片段这种做法并不高明，充其量只是字面匹配的一个变种而已，存在非常明显的缺点。你无法找到主题最相近的文档，因为在一开始，你就把文档的语义切割了，更何况你所能使用的开源向量检索，根本没办法满足工业级的性能和数据量级要求。
3. 各类开源模型，比如 ChatGML 和 Llama 是无法直接拿来满足商业需求的。在大模型商业化的过程中，模型的领域定制是免不了的。

## 这一轮技术革命的真正“终局”是什么样子

[具身智能：OpenAI真正的野心是什么？](https://time.geekbang.org/column/article/686408)

![](/public/upload/machine/llm_capacity.jpg)

1. 任务规划（Planning），CoT让 LLM 将任务分解为可解释的步骤
2. 记忆唤醒（Memory），在神经科学研究中，人类的记忆可分为感觉记忆、短期记忆和长期记忆三种类型。
    1. 感觉记忆，是人体接收到外部信号以后，瞬间保留的视觉、听觉、触觉的记忆片段，在 AI 系统中类似于高维嵌入表示，也就是我们常说的 “Embedding”。
    2. 短期记忆，是你当前意识中的信息，在 LLM 中类似于提示词（Prompt）中的所有信息。
    3. 长期记忆，包含了你能回忆的所有信息，在 LLM 中类似于外部向量存储。
    LLM 能“消化”的，只有提示词（Prompt）中的短时记忆，所以你需要在长期记忆中选择最重要的内容放入提示词。
3. 驾驭工具（Tools）

以上能力汇总下来
1. LLM 在得到任务后，会帮助你制定记忆唤醒方案。
2. AI 系统执行该方案，生成相关的查询指令，从外部数据中查询数据。PS：调取外部知识
3. 我们将这些数据交给 LLM 来判断是否已获得足够完成任务的数据。如果没有，LLM 会生成新的唤醒方案，并循环这个过程。
3. LLM 为指定的需求，找到最合适的工具，再下一步OpenAI 推出的 Code Interpreter 可以制作工具
5. 判断任务是否完成，如果没有，则重复上述过程。

## 其它

![](/public/upload/machine/beauty_of_llm.jpg)


