---

layout: post
title: 小鼠如何驾驭大象（LLM）？
category: 架构
tags: MachineLearning
keywords: llm chatgpt gpt bert

---

## 简介

* TOC
{:toc}

[张宏江：大模型发展机会与挑战](https://mp.weixin.qq.com/s/pjUaRD0YV2qb6MXZ-oVstQ)
1. 当模型足够大，语料足够多的时候，涌现这件事情出现就不足为奇。这就好比把你甩到一个外语环境中，见得多听得多，根本不用专门学语法就可以学会语言，这就是语料和模型规模的重要性。看的句子多了，就懂得语法；见的世面多了，就懂得推理和逻辑。ChatGPT在认知能力上前进了一大步，通过强化学习与NLP（自然语言处理）相结合，通过人的反馈强化学习，基本解决了自然语言理解与生成问题，并且展现出人类无中生有的原创能力。
2. 人们对知识的表示和调用发生了根本性变化。从关系数据库（SQL），到互联网信息检索，科技史上每次知识表示与调用方式的跃迁，都会掀起一次巨大的技术变革。
3. 大模型作为基础平台支撑无数智能应用。大模型在内容创意生成、对话、语言或风格互译、搜索等方面的能力，将为各应用领域带来百花齐放。而大模型基础平台，在数据层、模型层、中间层、应用层，都蕴藏着巨大发展机遇。

[热议的“中国版ChatGPT”，如何理解其意义？](https://mp.weixin.qq.com/s/wvLj4eWCX8jdpCECLjIZmw)
1. 张亚勤：我觉得可以把GPT这个系列的生成式AI模型看作一个由大模型组成的AI操作系统，和PC上的Windows，以及移动的安卓、iOS基本具有相似的意义。一个新的操作系统出来是什么意思？下面的硬件、上面的应用都会被重构、重塑，形成一个新的生态。
2. 生成式对话产品会颠覆搜索引擎现有的商业模式，科技公司不得不自我革命。你也会这么认为吗？我觉得不是。要是你没有这个产品的话，别人会革你的命。我们在搜索的时候，其实是在找知识，那现在有了生成式技术，它确实提供了一种找到知识的新能力。


姚志强：以前我们做的小模型，是就很像是人类的社会分工，直奔目标，比如这个算法就只做人脸识别、车牌识别，我去收集数据标注数据，然后去训练它，未来的可扩展性其实就没有很多。但现在大模型的训练，是**将它真正作为一个人来训练**。我们用专家知识去引导他，给他启发性的这样思维，真正的去教导他去引导他，这是出现了“涌现”现象的原因。
1. 未来，产品和技术演进思路全都要重新迭代，可能我们不会再有所谓的语音识别、自然语言理解、图像识别这些技术分类，剩下的只有AI——你是不是一家AI公司？判断AI基础能力的标准，可能就是大模型做得如何，在这个基础上再谈其他的行业模型、场景应用。
2. 对我们整个产品体系来说或产品架构来说其实影响不太大，更多是提升了我们的性能。原先我们可能说要不断的要在这里面添加小模型，那现在，我只要替换成一个大模型。而中间可能会有一些特殊的行业线应用我可能会变成行业模型。
3. 我们所说的人工智能三浪，第一浪是做是做单点的AI技术，比如做人脸识别、车牌识别，这是小模型时代了；第二浪是指把很多的技术进行组合，就串联起来，做成一个业务闭环，解决客户的实际问题，这里的流程会比较长，有时候可能不会因为一个点的技术提升就会导致整个流程有很大收益；第三浪是AI将成为未来世界的入口，形成平台和生态。我们认为，现在属于二浪到三浪的共振的时期。改变未来的交互的入口，大模型确实在做这样的事情。

池建强：未来企业，AI 会成为一个生产要素。除了员工之外，还会有一批“AI 员工”。AIGC 在应用上确实是超出所有人预料，但 ChatGPT，从技术视角来看，其实没有太强冲击性。技术的发展是线性的，只是公众的感知是阶段性的。AI 发展，到现在真正有突破性成功的有 4 个阶段。
1. 人来写规则，用人的经验来写程序。把专家的经验变成程序这个事现在业界还在实践。
2. 机器利用数据，写少量的规则。这时候开始有一些模型，比如决策树、简单的神经网络。
3. 机器用海量的数据，写大量的规则。这其实就是深度学习，或者叫专用大模型。广告、人脸识别就是用的这个。每个模型，只能解决一个问题。
4. 通用大模型。海量的数据，同一个模型，解决不同的问题。形式都是 Transformer 的续写形式，但能力是多样的，比如问答、总结、扩写。

## 发展脉络

从分析式AI（input ==> 预测值）到生成式AI，从domain-specific到通用，从fine-tune 到Prompt。

[ChatGPT成功背后的技术原因及其对生命科学领域的启发](https://mp.weixin.qq.com/s/snXaWHr0VYFNYirSHRAvRw)
1. 早在上个世纪五十年代，就有学者提出了人工智能（Artificial Intelligence）的概念，其目的是希望让计算机拥有人类智能（或部分人类智能）。这个领域经过很多年的发展，依然没有突破，直到2012年出现了深度学习技术。深度学习主要解决了模型表示能力的瓶颈。我们面对的建模问题，比如图像理解、语言翻译、语音识别、分子-蛋白结合构象预测等技术，都是非常复杂的非线性问题，在深度学习出现之前，模型表示能力很弱，无法对这些复杂问题进行精确表示。而**深度学习技术，可以通过模型的层次堆叠，理论上可以构建任意深度的模型，突破了模型表示能力的瓶颈**，从而在语音识别、计算机视觉、自然语言理解等领域取得了突破性进展。
2. 这个阶段的主要局限，是非常依赖于标注数据的数量。由于模型参数变多，想要求解这么多的模型参数，需要大量的训练数据作为约束。而**想获得大量的标注数据非常贵，到亿级别之后就很难再有提升，数据支撑的有效模型大小也受到限制**。
3. 2017年，一个重要的基础工作Transformer出现了。2019年，一个叫作BERT的工作脱颖而出，BERT采用了一个叫作自监督预训练的思路，无需标注数据**仅利用文本语料本身存在的约束就可以训练模型**（比如某句话的某个位置只能用某些限定的词），这样互联网上存在的优质语料不需要进行人工标定就可以用来做训练，从而一下子使得可用训练数据的数量有了巨大的提高，再配合上大模型，使得BERT模型的效果远远超过过去的模型，并且在不同任务间具有很好的通用性，成为NLP领域里程碑工作之一。其实在BERT出现之前的2018年，还有个工作叫作GPT（即GPT1.0），更早利用了自监督预训练的思路来做文本生成，即输入前面的文本，模型预测输出后面的文本，领域里面的优质语料无需标注就可以做训练。**BERT和GPT都是在Transformer基础上发展而来的，而Transformer也逐渐发展成为AI领域的通用模型**。
4. 在自监督预训练技术出现之后，我们可以认为新一代人工智能发展到了第二个阶段，即自监督预训练技术使得可用训练数据有了几个数量级的提升，**在训练数据大幅提升的支撑下，模型大小也有了数个数量级的提升（有效模型达到了千亿规模）**，而在模型效果上，这些模型变得不再依赖于下游任务领域数据的再训练，所以，**领域进入到基于自监督预训练的通用大模型时代**。
5. ChatGPT为什么能有这样惊艳的效果？其中一个核心原因是ChatGPT基于生成大模型GPT3.5构建，这应该是当前自然语言理解领域文本生成最好的模型（GPT3.5比GPT3.0使用了更多的数据和更大的模型，具有更好的效果）。第二个核心原因则是基于人类反馈的强化学习技术：第一步，先收集用户对于同一问题不同答案的偏好数据；第二步，利用这个偏好数据重新训练GPT模型，这一步是基于监督信息的精调；第三步，根据用户对于不同答案的偏好，训练一个打分函数，对于ChatGPT的答案会给出分数，这个分数会体现出用户对于不同答案的偏好；第四步，用这个打分函数作为强化学习的反馈（Reward）训练强化学习模型，使得ChatGPT最终输出的答案更偏向于用户喜欢的答案。通过上述过程，ChatGPT在GPT3.5的基础上，针对用户输入，输出对用户更友好的回答。ChatGPT第一阶段训练GPT生成模型使用的训练数据非常多，大约在几十TB，训练一次模型需要花费千万美元，而第二个阶段，基于强化学习的少量优质数据反馈则只需要数万条优质数据。这种新的范式，**有可能成为第三阶段人工智能的核心驱动技术，即首先基于自监督预训练的大模型，再结合基于少量优质数据反馈的强化学习、Prompting等技术，形成模型和数据的闭环反馈，获得进一步的技术突破**。如果这个技术走通，那么无人驾驶、机器人以及生命科学等数据获取昂贵的领域将显著受益。
6. ChatGPT并不能证明人工智能已经有了人类心智，ChatGPT表现出来的一些创造性和心智，是因为自然语言理解语料中包含了语义、逻辑，基于自然语言语料训练出来的生成模型，**统计意义上学习到了这些对应关系**，看起来似乎有了智能，但并不是真的有人类心智。ChatGPT很棒，但说他智力等于几岁小朋友的说法，都不够严谨。因为从根本上讲，人学习新知识、进行逻辑推理、想象、运动反馈这些能力，目前AI还没有具备。
7. ChatGPT并不是一两个研究人员做出的算法突破，而是在先进理念指导下，非常复杂的算法工程体系创造出来的成果，需要在团队和组织上匹配（类比OpenAI和DeepMind）。纯研究型的团队恐怕不能成功，对深度学习理解不够、太工程化的团队也不会成功。这只团队需要：第一要有足够资源支持，可以支撑昂贵的深度学习训练和人才招聘；第二要有真正在工业界领导过工程化大模型团队的专家领导，ChatGPT不仅有算法创新，更是工程体系创新；第三，也可能是最重要的，需要一个团结协作有统一领导且不追求论文发表的组织（松散型的组织利于算法创新，但不利于工程化算法攻坚），且配备足够多优秀的工程和算法人才。

脉络：由于自然语言任务种类繁多，且任务之间的差别不太大，所以为每个任务单独微调一份大模型很不划算 ==> pre-train model ==> 如何驾驭pre-train model?(Prompt Learning & Prompt Tuning）)

## 自然语言处理基础

自然语言处理(Natural Language Processing, NLP) 被誉为“人工智能皇冠上的明珠”，一方面表明了它的重要性，另一方面也突出了它的技术难度。简单来说，NLP要做的事就是利用计算机实现自然语言数据的智能化处理、分析和生成，以期让计算机实现听、说、读、写、译这些人类所具备的语言能力。

1. 词表示。
    1. synonym and hypernym。用一个词相关的词来表示一个词
    2. one-hot。假定所有的文字一共有 N 个单词（也可以是字符），我们可以将每个单词赋予一个单独的序号 id，那么对于任意一个单词，我们都可以采用一个 N 位的列表（向量）对其进行表示。 缺点：这样会导致词汇与词汇之间是没有任何关联的。
    3. represent word by context
    4. word embedding。基于神经网络的词的向量表示方法。
2. 关键词的提取，关键词，顾名思义，就是能够表达文本中心内容的词语。
    1. 基于统计特征的方法
    2. 基于词图模型的关键词提取
    3. 基于主题模型的关键词提取
2. 语言模型。语言模型是根据语言客观事实而进行的语言抽象数学建模，是一种对应关系。根据前文预测下一个词是什么：计算一个序列的词成为一句话的概率是多少；根据已经出现的词，计算某个词出现的概率
    1. 统计语言模型。本质是基于词与词共现频次的统计。给定一个句子 `S=w1,w2,w3,…,wn`，则生成该句子的概率为：`p(S)=p(w1,w2,w3,w4,w5,…,wn)`，再由链式法则我们可以继续得到：`p(S)=p(w1)p(w2|w1)p(w3|w1,w2)…p(wn|w1,w2,…,wn-1)`。那么这个 p(S) 就是我们所要的统计语言模型。有一个非常本质的问题并没有被解决，那就是语料中数据必定存在稀疏的问题，公式中的很多部分是没有统计值的，那就成了 0 了，而且参数量真的实在是太大了。
        1. N-gram，前面出现的N个词，出现xx概率多大。但是如果 n 比较大，或者相关语料比较少的时候，数据稀疏问题仍然不能得到很好地解决。这就好比我们把水浒传的文本放入模型中进行统计训练，最后却问模型林冲和潘金莲的关系，这就很难回答了。因为基于 ngram 的统计模型实在是收集不到两者共现的文本。
    2. 神经网络语言模型。a neural language model is a language model based on netual networks to learn distributed representations of words. 给每个词分别赋予了向量空间的位置作为表征，从而计算它们在高维连续空间中的依赖关系。

有没有一种方法，可以**把语言变成一种数学计算过程**，比如采用概率、向量等方式对语言的生成和分析加以表示呢？之前很方案都是基于 符号、统计的，引入神经网络之后，一般用一个向量表示一个词，向量是学习出来的，并且可以根据新的语料学习调整。 

什么是语言模型？其实每个人都用到过语言模型，那就是拼音输入法。拼音输入法的本质就是一个语言模型，用户给定一串拼音之后，比如“wo he ni”，每个拼音下都有很多的候选汉字，多个拼音就会组合爆炸，屏幕上不可能把所有组合展示出来让用户选，只能展示一个或几个最可能的汉字组合。可能性如何判断？这就要用到中文语言模型，任意一个中文串，语言模型可以给出这个中文串是一个正常人类句子的概率大小。比如“我和你”是正常人类句子的概率要明显大于“窝核腻”、“我喝泥”等等，所以最终给用户呈现“我和你”。此外，现代输入法通常都有联想功能，当你输入“wo he ni”之后，输入法不止能猜到你想输入“我和你”，还会给出后面的联想“我和你一起”，这也是基于语言模型。给定前面若干个单词，预测下一个单词是什么；然后模型将预测的单词加入到给定单词序列，继续预测下一个；如此递归直到预测下一个单词为结束符号或达到要求长度。如果一开始给定的单词序列为我们提问的一个问句，我们认为它的后续输出为问题的答案，那这个语言模型就变成了一个问答系统，ChatGPT的本质正是如此。

## 机器怎么看懂人类的文字？

[李宏毅-BERT and its family](https://www.bilibili.com/video/BV1eV411d7Kp)

![](/public/upload/machine/pre_train_fine_tune.jpg)

以往的NLP任务都是为每个任务分配一个模型，之后用**对应任务大量的标注数据**去训练这个模型。pre-train和fine-tune的流程是使用**大量的无标注文本**去预训练好一个模型，让这个模型可以初步的了解人类的语言，之后再使用对应任务的标注数据，去微调这个模型。这个过程和人类学习语言的过程是十分接近的。比如考托福考试，需要有听说读写这些测试。但是人类的学习的过程并不是直接去学习这些题目的做法，而是通过阅读大量的英文语料去掌握英文，之后再学习这个题目的解法，达到解题的效果。

### Pre-training

给出一段文本，OpenAI 就能返回给你一个 Embedding 向量，这是因为它的背后是 GPT-3 这个超大规模的预训练模型（Pre-trained Model）。
1. 这个 API 可以把任何你指定的一段文本，变成一个大语言模型下的向量，也就是用一组固定长度的参数来代表任何一段文本。
2. 提前计算“好评”和“差评”这两个字的 Embedding。对于任何一段文本评论，我们也都可以通过 API 拿到它的 Embedding。
3. 我们把这段文本的 Embedding 和“好评”以及“差评”通过余弦距离（Cosine Similarity）计算出它的相似度。然后我们拿这个 Embedding 和“好评”之间的相似度，去减去和“差评”之间的相似度，就会得到一个分数。如果这个分数大于 0，那么说明我们的评论和“好评”的距离更近，我们就可以判断它为好评。如果这个分数小于 0，那么就是离差评更近，我们就可以判断它为差评。
PS： 对于大模型，即便没有在针对具体的业务场景进行专门的训练（比如电影评论、商品评论），以上面情感分析为例，使用预训练模型给出来的向量，直接根据距离做的判断，其准确率也很厉害了。

what is pre-train model（也被称为foundation model）？ **represent each token by a embedding vector**.
1. contextualized word embedding。比如bank 单词有两种或三种意思，对于不同的意思的token，会根据其经常出现的上下文，学习一个 embedding token。 相关方法如ELMO等。
2. 不同于以往的embedding：输入一个token，输出一个embedding。contextualized word embedding是在输入一整个句子以后，输出这个句子中各个token的embedding。这样这个token的embedding就是在看过这个token的上下文后，输出token embedding，这个embedding就包含了上下文的信息。**每个词的向量，随着位置以及前后词的不同，编码出来的结果是不一样的。**
2. contextualized word embedding的模型就像是一个encoder，用于编码信息。通常是非常深的网络，可以用到lstm，可以用自注意力层。
    ![](/public/upload/machine/pre_train_model.jpg)

NLP任务一般又被分为自然语言理解（NLU）和自然语言生成（NLG）两大类，对应的不同的无监督预训练目标。其中，自回归（Autoregressive，简称AR）语言建模和自编码（Autoencoder，简称AE）一直是最成功的两个预训练目标。Transformer encoder是一个AE模型，Transformer decoder则是一个AR模型。

1. AR模型，代表作GPT，从左往右学习的模型。AR模型从一系列time steps中学习，并将上一步的结果作为回归模型的输入，以预测下一个time step的值。AR模型通常用于生成式任务，优缺点如下：
    1. 优点：AR模型擅长生成式NLP任务。AR模型使用注意力机制，预测下一个token，因此自然适用于文本生成。此外，AR模型可以简单地将训练目标设置为预测语料库中的下一个token，因此生成数据相对容易。
    1. 缺点：AR模型只能用于前向或者后向建模，不能同时使用双向的上下文信息，不能完全捕捉token的内在联系。
2. AE模型，代表作BERT，它不会进行精确的估计，但却具有从被mask的输入中，重建原始数据的能力，即fill in the blanks（填空）。**测出该位置应该出现的那个正确词汇，这就意味着模型能够“吃透”上下文语义信息**。AE模型通常用于内容理解任务，比如自然语言理解（NLU）中的分类任务：情感分析、提取式问答。AE模型的优缺点如下：
    1. BERT使用双向transformer，**在语言理解相关的任务中表现很好**。
    2. 输入噪声：BERT在预训练过程中使用【mask】符号对输入进行处理，这些符号在下游的finetune任务中永远不会出现，这会导致预训练-微调差异。而AR模型不会依赖于任何被mask的输入，因此不会遇到这类问题。且基于一个独立假设：在给定了unmasked tokens时，所有待预测（masked）的tokens是相互独立的。

3. 针对机器翻译这种序列到序列的任务（同时需要内容理解和生成的任务），往往会将模型组织为完整的编码器-解码器架构。它将每个task视作序列到序列的转换/生成（比如，文本到文本，文本到图像或者图像到文本的多模态任务）。

![](/public/upload/machine/bert_vs_gpt.png)

||BERT|GPT|
|---|---|---|
|预训练的方式不同|双向语言模型，通过左右两侧的单词序列来预测中心单词的表示|单向语言模型，通过左侧的单词序列预测右侧的单词序列|
|目标不同|预测中心单词|生成下一个单词/预测下一个单词的概率分布|
|预训练数据集不同|主要使用了BooksCorpus和Wikipedia数据集|使用了互联网上的大规模文本数据集，包括维基百科、新闻、小说等等|
|模型结构不同|由多个Transformer编码器组成，最后一层会输出整个输入序列的表示|由多个Transformer解码器组成，只输出最后一个单词的表示|

### Task-specific Fine-tuning

how to fine-tune? fine-tune部分旨在根据预训练的model添加部分层从而可以解决下游任务。

![](/public/upload/machine/fine_tune.jpg)

**如何在预训练好的模型中再加入一部分让其可以实现下游任务？**现有的NLP任务的分类，其中按照输入可以分为两类，按照输出可以分为四类(one class;class for each token;copy from input;general sequence)。

输入可以分为两类
1. one sentence; 如句子分类
2. mutliple sentences； 比如QA，自然语言推理，需要在两个句子之间加入一个特殊的符号`[SEP]`（转为一个句子）。

输出可以分为四类
1. one class; BERT的解法是让一个特殊的符号`[CLS]`作为整个句子的表示，之后将`[CLS]`的embedding输入到一个分类器中，进行分类任务。也可以像其他模型一样，将所有token的embedding都输入到一个模型中（可以是各个token embedding的均值，也可以是各个token输入到RNN，再得到下一层的嵌入），进行分类。
2. class for each token; 如果任务是对每一个token进行分类的话，就需要将每一个token的embedding输入到一个网络中，对其进行分类。
3. copy from input。 比如说Extraction-based QA任务，其任务就是输入一段原文和一个问题，之后在原文中标注好哪个token是开始，哪个token是结尾。BERT论文中的解法就是设计了两个可以训练的embedding（一个是start，一个是end），之后用start和end向量分别和BERT得到的嵌入求内积，之后再通过softmax，计算哪个最大，就是最后的结果。
4. general sequence。生成任务
    1. BERT可以作为一个encoder，需要我们自己去设计一个decoder，但是decoder是没有经过预训练的。
    2. 让pre-training模型当作decoder来使用，其方法就是输入一个[sep]之后让model输出一个东西，再将模型的输出作为模型的输入，以此类推，不断的得到输出结果。

如何进行fine-tune呢？
1. fix住pre-train模型（feature extractor），只fine tune特定任务的模型。
2. 将特定任务模型和pre train的模型一起进行fine tune（也会改pre-train 部分的参数）。
    1. 问题是pre train的model是一样的，但是经过fine tune后，每个model是完全不同的，但是每一个model都是非常巨大的，NLP有很多的任务，如果每一个任务都要存储一个很大的模型，也许是行不通的。因此有了adaptor的概念。也就是说为每一个model存储一个adaptor（比如在原来的pre-train网络中加几层作为adapter，pre-train时不参与，fine-tune时进仅更新adapter。adapter插在pre-trian model 哪里有很大的的研究空间，花样很多，有专门的adapterhub），在fine-tune的时候，仅仅改变adaptor，并没有改变其他的信息（pre-train）。因此在存储模型的时候，只需要存储原来模型中的部分，以及每一个下游任务上的adaptor即可完成任务。所以这样的话，存储的参数量就少了很多。

how to pre-train?
1. 最早的跟预训练有关的模型，应该是CoVe，是一个基于翻译任务的一个模型，其用encoder的模块做预训练。但是CoVe需要大量的翻译对，这是不容易获得的，能不能通过一大段没有标注的语料进行预训练呢？
2. 比较直觉的self-supervised learning就是**预测下一个单词是什么**。给出的解法就是将一个token输入到网络中，经过softmax之后，得到下一个token的概率分布。

    ![](/public/upload/machine/pre_train.jpg)
1. 其中使用LSTM（上图的model = LSTM）做predict next token的工作有elmo，以及ulmfit。
2. 使用self-attention的方式（上图的model = LSTM）进行next token prediction。

有哪些预训练模型？

1. Left-to-Right LM: GPT, GPT-2, GPT-3。适合文字接龙
2. Masked LM: BERT, RoBERTa。适合文字填空
3. Prefix LM: UniLM1, UniLM2
4. Encoder-Decoder: T5, MASS, BART

## 对于大模型的两种不同的期待

[对于大模型的不同期待所衍生的两类使用方式](https://www.bilibili.com/video/BV1jA411274Q?p=9)

1. 成为专才。比如bert（做文字填空的，所以不能“说话”）
    1. 在进行具体的任务之前需要改造：加外挂（即为模型加额外模块）和微调参数（fine tune）。
    2. 有机会在专一任务有机会跑赢通才。
2. 成为通才。
    1. 需要额外进行prompt。 
    2. Multitask learning as Question Answering。所有自然语言的处理都是问答问题。
    2. 只要重新设计 prompt 就可以快速开发新功能，不用写程序。

比如做情感分析，你可以专门做一个情感分析的模型。也可以你给一点情感分析的例子，让模型去做文字接龙。

![](/public/upload/machine/in_context_learning.jpg)

再进一步，毕竟找范例有点麻烦，让机器根据叙述知道我们让它干嘛（instruction-tuning读懂人类的指令）。把任务用人类的语言描述出来，变成一个dataset，然后让llm 学到你让它干嘛，进而可以 generalized 到没有看过的指令上。

![](/public/upload/machine/instruction_tuning.jpg)

###  GPT-1到ChatGPT的演进

[GPT-1到ChatGPT的演进和技术原理](https://mp.weixin.qq.com/s/iGV9ddCnH3M3-EW4l-TOYA)Transformer的出现完全打开了大规模预训练语言模型(Pre-trained Language Model , PLM)的空间，并且奠定了生成式AI的游戏规则。
1. Transformer相比之前论文的novalty在于：大胆地抛弃了传统的CNN和RNN基础模型，整个网络结构完全是由Attention机制组成。更准确地说，Transformer由且仅由自注意力(self-Attenion)机制和前馈神经网络(Feed Forward Neural Network)组成。
2. 从实际应用的角度来看，Transformer的主要贡献(contribution)在于以下几个方面：
  1. 突破了RNN模型不能并行计算的限制
  2. 精度和模型复杂度相比RNN + Attention系列模型更优
  3. Transformer本身也可以作为base model扩展

BERT仅使用了Transformer的编码器(Encoder)部分进行训练，而GPT-1则只使用了Transformer的解码器(Decoder)部分。
1. GPT-1: 预训练+微调模式，117M参数、12层、2亿单词
    1. 预训练阶段：基于Transformer Decoder架构，以语言建模作为训练目标(自监督，根据已知的词预测未知的词)。
    2. 微调阶段：将训练好的Decoder参数固定，接上一层线性层，通过有监督训练任务微调线性层的参数，从而进行预测。
2. GPT-2的目标是试图用一个模型去做多个NLP任务，它的核心思想就反映在论文标题里：语言模型=无监督多任务学习。
    1. 通俗地解释一下：语言模型实际上是一种自监督的方式，根据已知的词预测未知的词，只是不需要显示地定义哪些字段是要预测的输出。那如何用无监督多任务的训练方式实现语言模型自监督训练+多任务微调的效果呢？我们只需要将input、output和task都表示为数据，例如在一个英文翻译成法语的机器翻译任务中，我们只需要将样本、标签和任务表示成`(translate to french,english text,french text)`，就实现了对`P(output|input,task)`的建模。
    2. 重要的是，这种方式可以实现无监督训练，并且里面的task可以变化，也就是说现在GPT-2可以实现无监督多任务训练而不需要第二阶段分不同任务有监督的微调！
    3. 最后我们看到，GPT-2相对于GPT-1，最大的改进就是**去掉了第二阶段的微调**(fine-tune)层，实现了多任务训练和zero-shot方式(Zero-shot learning，零样本学习)直接接诸多的下游任务，在多个任务下都可以取得很好的效果。
3. GPT-3 基本继承了GPT-2的模型架构和训练模式，主要的改进点在于：in-context learning(上下文情境学习，ICL) 和 few-shot learning(小样本学习，FSL)配合服用。
    1. in-context learning(上下文情境)学习机制：可以理解为给模型加一定的先验知识，适当对模型进行引导，教会它应当输出什么内容。只给提示就是zero-shot，给一个示例叫做one-shot，给少量多个示例就是few-shot。
    1. zero-shot，不需要提供关于这个问题或话题的资料，比如你直接说：给我写首诗。你不需要告诉它写什么样子的诗。
    2. one-shot/few-shot，需要提供一些关于这个问题或话题的资料，这样它可以更好的理解你的问题或话题，比如“请写一篇关于狗的文章，狗有四条腿，可以当宠物”。
4. InstructGPT相对GPT-3要解决的是大模型的alignment(对齐)问题。其背景是：大型语言模型会生成一些不真实、有毒(不符合人类道德伦理等)或对用户毫无帮助的输出，显然这些与用户期待的不一致。
    1. 大模型在预训练过程中见识了各种各样的数据，因此针对一个prompt/instruct(提示)会输出什么东西，也可能是多种多样的，但是预训练数据中出现的数据模式，不代表都是人类在使用模型时希望看到的模式，因此需要一个alignment(对齐)的过程，来规范模型的“言行举止”。而实现这个过程InstructGPT引入了RLHF机制(人类反馈强化学习)，实际上6年前的AlphaGo正是充分利用了强化学习，才在围棋领域实现了所到之处无敌手。简单点说，InstructGPT就是在GPT-3基础上利用RLHF机制(人类反馈强化学习)做了微调，以解决大模型的alignment(对齐)问题。
    2. ：整个过程就是老师（人类标注员）先注入一些精华知识，然后让模型试着模仿老师的喜好做出一些尝试，然后老师对模型的这些尝试进行打分，打分之后，学习一个打分机器，最后打分机器就可以和模型配合，自动化地进行模型的迭代，总体思路称为RLHF：基于人类反馈的强化学习。

[从 GPT 到 ChatGPT 的演进与应用思考](https://mp.weixin.qq.com/s/3Pr82xKpZ7mAWQcxPPB1xA)使用GPT-3执行NLP任务时，不需要重新更新模型，只需要向其发送一句提示（Prompt）例如「请给这段文字分类，类别标签有A、B、C」即可完成分类，或者可以使用少量标注数据作为例子告诉模型（Few-Shot），能够取得更优的效果。ChatGPT是从GPT-3发展而来的，符尧等人在《拆解追溯 GPT-3.5 各项能力的起源》一文中总结了GPT-3到GPT-3.5的进化树，GPT-3在OpenAI API中的模型名称为Davinci（达芬奇），之后经历在代码上训练、指令微调、RLHF（Reinforcement Learning from Human Feedback，基于人类反馈的强化学习）等过程，进化成ChatGPT，这里不再赘述。2022年11月，OpenAI除了发布ChatGPT之外，还发布了text-davinci-003模型，两者都是在text-davinci-002模型的基础上使用RLHF方法训练得到的，**ChatGPT实际上不仅是一个单独的模型，而是一个完整的Web聊天机器人产品**。

### Prompt

[我对Prompt Engineering的理解](https://mp.weixin.qq.com/s/fLtYMwqefoDSeypOuY8bUA)“提示工程（Prompt Engineering）” 这一概念源于语言模型的发展，它描述了如何有效地**利用提示从语言模型中提取信息**的过程，通常应用于现实世界的应用场景中。 PS：准备样本 ==> 准备提示
1. 在语言模型中，“提示” 是用户提供给模型的输入。在 ChatGPT 中，它可以理解为你输入文本框的文字。然后，语言模型根据你的提示 “推断” 出一个 “补全”。
2. “提示工程” 是利用提示作为一种从模型中提取所需信息的方法。这种方法很有吸引力，因为你不需要大量的离线训练数据集，不需要离线访问模型，而且对于非工程师来说也很直观。提示只是调整模型的一种方式。
3. “提示工程” 是一种更严谨的领域，**旨在利用提示作为一种为实际应用构建可靠功能的方法**。它与 ChatGPT 式的提示有所不同，因为通过提示工程生成的提示通常用于在高频、多样化的场景中反复使用，**以便为应用程序可靠地解决特定问题**。

GPT-3论文定义：如果需要（基于梯度下降为主的算法）对模型参数进行更新，就是fine-tune。如果不需要修改模型和参数，只要给模型一些提示和样例，就让模型复合我们的一些要求完成一些任务就叫in-context learning，后面大家开始叫prompt。GPT 模型可以使用prompt 和 fine tune两种方式进行训练和使用，取决于具体的应用场景和任务需求。prompt 是第一种针对GPT 模型的特殊训练方式，**不需要大量数据，不需要对模型参数进行改动，也就意味着可以不部署模型，而是接入公开的大预言模型服务（MaaS）**。缺点是，模型生成的内容受限于提示信息，不能够完全发挥模型的潜力。PS：即便是AGI，你也得在具体提问上需要告诉模型任务是什么。


[一文详解Prompt学习和微调（Prompt Learning & Prompt Tuning）](https://zhuanlan.zhihu.com/p/620222350)

1. 过去许多机器学习方法是基于全监督学习（fully supervised learning）的。由于监督学习需要大量的数据学习性能优异的模型，而在 NLP 中大规模训练数据（指为特定任务而标注好的数据）是不足的，因此在深度学习出现之前研究者通常聚焦于**特征工程**（feature engineering），即利用领域知识从数据中提取好的特征；
2. 在深度学习出现之后, 由于特征可以从数据中习得，因此研究者转向了**结构工程**（architecture engineering），即通过通过设计一个合适的网络结构来把归纳偏置（inductive bias）引入模型中，从而有利于学习好的特征。
3. 在 2017-2019 年，NLP 模型开始转向一个新的模式（BERT），即预训练 + 微调（pre-train and fine-tune）。在这个模式中, 先用一个固定的结构预训练一个语言模型（language model, LM），预训练的方式就是让模型补全上下文（比如完形填空）。由于预训练不需要专家知识，因此可以在网络上搜集的大规模文本上直接进行训练。然后这个 LM 通过引入额外的参数或微调来适应到下游任务上。此时研究者转向了**目标工程**（objective engineering），即为预训练任务和微调任务设计更好的目标函数。
4. 在做 objective engineering 的过程中，研究者发现**让下游任务的目标与预训练的目标对齐是有好处的**（预训练是文字接龙，就把目标任务也改为文字接龙的形式，预训练是文字填空，就把目标任务也改为文字填空）。因此下游任务通过引入文本提示符（textual prompt），把原来的任务目标重构为与预训练模型一致的填空题。比如一个输入 “I missed the bus today.” 的重构：
    1. 情感预测任务。输入：“I missed the bus today.I felt so___.” 其中 “I felt so” 就是提示词（prompt），然后使用 LM 用一个表示情感的词填空。
    2. 翻译任务。输入：“English:I missed the bus today. French: ___.” 其中 “English:” 和 “French:” 就是提示词，然后使用 LM 应该再空位填入相应的法语句子。
5. 我们发现用不同的 prompt 加到相同的输入上，就能实现不同的任务，从而使得下游任务可以很好的对齐到预训练任务上，实现更好的预测效果。后来研究者发现，在同一个任务上使用不同的 prompt，预测效果也会有显著差异，因此现在有许多研究开始聚焦于 **prompt engineering**。

[五万字综述！Prompt Tuning：深度解读一种新的微调范式](https://mp.weixin.qq.com/s/-lfq63NrsqUgmvYNzogCew)
1. Prompt-Tuning自从GPT-3被提出以来，从传统的离散、连续的Prompt的构建、走向面向超大规模模型的In-Context Learning、Instruction-tuning和Chain-of-Thought。
2. 自从GPT、EMLO、BERT的相继提出，以Pre-training + Fine-tuning 的模式在诸多自然语言处理（NLP）任务中被广泛使用，其先在Pre-training阶段通过一个模型在大规模无监督语料上预先训练一个 预训练语言模型（Pre-trained Language Model，PLM） ，然后在Fine-tuning阶段基于训练好的语言模型在具体的下游任务上再次进行 微调（Fine-tuning） ，以获得适应下游任务的模型。这种模式在诸多任务的表现上超越了传统的监督学习方法，不论在工业生产、科研创新还是竞赛中均作为新的主流方式。然而，这套模式也存在着一些问题。例如，在大多数的下游任务微调时，**下游任务的目标与预训练的目标差距过大 导致提升效果不明显，微调过程中依赖大量的监督语料** 等。
3. 至此，以GPT-3、PET为首提出一种基于预训练语言模型的新的微调范式——Prompt-Tuning ，其旨在**通过添加模板的方法来避免引入额外的参数**，从而让语言模型可以在小样本（Few-shot）或零样本（Zero-shot）场景下达到理想的效果。
4. 以二分类的情感分析作为例子，给定一个句子`[CLS] I like the Disney films very much. [SEP]`
    1. 传统的Fine-tuning方法是将其通过BERT的Transformer获得 `[CLS]`表征之后再喂入新增加的MLP分类器进行二分类，预测该句子是积极的（positive）还是消极的（negative），因此需要一定量的训练数据来训练。
    2. Prompt-Tuning则执行如下步骤：
        1. 构建模板（Template Construction） ：通过人工定义、自动搜索、文本生成等方法，生成与给定句子相关的一个含有`[MASK]`标记的模板。例如`It was [MASK]`，并拼接到原始的文本中，获得Prompt-Tuning的输入：`[CLS] I like the Disney films very much. [SEP] It was [MASK]. [SEP]`。将其喂入BERT模型中，并复用预训练好的MLM分类器，即可直接得到`[MASK]`预测的各个token的概率分布；
        2. 标签词映射（Label Word Verbalizer） ：因为`[MASK]`部分我们只对部分词感兴趣，因此需要建立一个映射关系。例如如果`[MASK]`预测的词是“great”，则认为是positive类，如果是“terrible”，则认为是negative类。
    3. 不同的句子应该有不同的template和label word，没错，因为每个句子可能期望预测出来的label word都不同，因此如何最大化的寻找当前任务更加合适的template和label word是Prompt-tuning非常重要的挑战。
    4. 其实我们可以理解，引入的模板和标签词本质上也属于一种数据增强，通过添加提示的方式引入先验知识。
5. GPT-3开创性提出 in-context learning 概念，即无须修改模型即可实现few-shot/zero-shot learning。同时引入了demonstrate learning，即让模型知道与标签相似的语义描述，提升推理能力。
    1. In-context Learning ：是Prompt的前身。其通过从训练集中挑选一些样本作为任务的提示提示（Natural Language Prompt），来实现免参数更新的模型预测；
    2. Demonstration Learning ：添加一些新的文本作为提示。例如在对“I like the Disney film. It was [MASK]”进行情感分析时，可以拼接一些相似场景的ground-truth文本“I like the book, it was great.”、“The music is boring. It is terrible for me.”等。此时模型在根据新添加的两个样例句子就可以“照葫芦画瓢”式地预测结果了。

[ChatGPT Prompt工程：设计、实践与思考](https://mp.weixin.qq.com/s/AizUBFssilX2S9aRfuz3_g) 未细读。


## chatgpt 是怎么炼成的？

[ChatGPT (可能)是怎么炼成的 - GPT社会化的过程 (李宏毅)](https://www.bilibili.com/video/BV1U84y167i3)

![](/public/upload/machine/gpt_to_chatgpt.jpg)

1. 学习文字接龙
    1. 输入“你好”，gpt 可以接“美”（你好美）。当然，“你好” 后面也可以是 “嘛”，也可以是“高”。gpt 的输出是随机的，哪个在它学习的素材里出现的概率高就显示哪个。
    2. 文字接龙的学习是不需要人工标注的，网络上的每一段文字都可以教机器做文字接龙。
    2. 文字接龙有什么用？可以回答问题。你问gpt “台湾最高的山是那一座？”，gpt 可能接“玉”，你输入“台湾最高的山是那一座？玉”，它可能会接“山”。我们就知道答案是“玉山”。
    4. 你问gpt “台湾最高的山是那一座？”，gpt 也能有其它回答，比如gpt学习的素材里有一个选择题：“台湾最高的山是那一座？A 玉山；B 雪山”，也可能“台湾最高的山是那一座？谁能告诉我答案？”。这个时候chatgpt 是一个自由自在的孩子。PS：基础LLM(Base LLM)的特点是基于大量文本训练数据，来预测下一个最有可能出现的单词，缺点是不可控，容易输出有问题的文本。
2. 人类老师引导文字接龙方向。gpt ==> chatgpt
    1. gpt 在网络上看到过各式各样奇怪的东西，可能产生各式各样奇怪的回答，不知道哪些是人类希望它回答的。
    1. 找人来思考想问gpt的问题，并人工提供正确答案。针对“台湾最高的山是那一座？”，gpt 有多个回答，然后由人来告诉它（标注） 人类想要的回答是“玉山”，人类只需要告诉机器，哪个答案是比较好的，哪个答案是比较差。
3. 模仿人类老师的喜好
    1. 训练一个模仿人类老师的模型，teacher model： 给一个问题，再给一个gpt 提供的答案，它负责输出一个分数。它学习的目标就是模仿人类的标准/偏好。
4. 用增强式学习向模拟老师学习
    1. 问gpt “世界最高的山是哪座？”，gpt 接了一句“世界上最深的海又在哪里？”，这是 对gpt 是一个合理的回答，但不是人类想要的。
    3. 把上述问题 和答案丢给 teacher model（已经学会了人类的偏好），teacher model 给一个score，也就是增强式学习（reinforcement learning）的reward。
    4. 接下来就是根据 reward 调整gpt的参数，目标是获取更高的score。经过reinforcement learning之后，就是chatgpt 了。

使用者感受chatgpt 的功能是：生成式学习。但chatgpt 实际做的事儿是 分类：给一句话，从所有的word 中选出一个word输出。 

[为什么ChatGPT用强化学习而非监督学习？](https://mp.weixin.qq.com/s/4USDakdomupWuwwhex6fMg)
1. 模型通过生成答案并接收反馈来学习
    1. 在强化学习中，我们为模型提供指令，但并不提供人工编写的答案。模型需要自己生成答案。评分机制（例如人类）会读取生成的答案，并告诉模型这些答案的质量。模型的目标是如何回答以获得高分。
    2. 另一种机制是模型生成多个答案，评分机制告诉模型哪个答案最好。模型的目标是学习生成高分的答案，而不是低分的答案。
2. 语言模型（至少）有三种交互模式：
    1. 文本型（text-grounded）： 为模型提供文本和说明（“总结此文本”，“基于此文本，以色列的人口是多少”，“本文中提到的化学名称是什么”，“将此文本翻译成西班牙语”等），让模型基于我们提供的文本生成答案；
    2. 求知型（knowledge-seeking）： 向模型提供问题或指导，让模型根据内在知识（“流感的常见原因是什么”）提供（真实）回答。
    3. 创造型（creative）： 为模型提供问题或说明，然后让模型进行创造性输出。（“写一个关于...的故事”）
2. 对于语言生成模型来说，监督学习/指令调优最大的问题是它们只能复制演示者给出的确切答案，但实际上，人类语言可以用多种方式传递相同的信息，它们都是切实可行的。如果因模型轻微偏离人类规定的文本而受到“惩罚”，可能会使模型产生困惑。我们当然可以继续逼迫模型去学习更难学习的遣词造句，尽管模型已经学会了生成具有同样意思、合法的替代性回答。因此，我们非常看好强化学习训练提供的多样性表达。
3. 监督学习只允许正反馈（我们向模型展示一系列问题及其正确答案），而RL允许负反馈（模型被允许生成答案并得到反馈说“这答案是不正确的”），相比正反馈，负反馈要强大得多。
4. 对于求知型查询，我们希望模型在对答案没把握的情况下能够如实回答“我不知道”或拒绝回答这一问题。对于这类交互模式，由于监督训练可能会让模型撒谎，所以我们必须使用RL。核心问题是：我们希望模型根据内部知识进行回答，但我们并不知道模型内部知识包含的内容。 在监督训练中，我们给模型提供问题及正确答案，并训练模型复制提供的答案。这里有两种情况：（1）模型“知道”答案。这种情况下，监督学习能够正确推动模型将答案与问题相关连，并且有望让模型执行相似的步骤，回答将来遇到的类似问题。这是所期望的行为。（2）模型不知道答案。在这种情况下，监督训练还是会促使模型给出答案。现在，我们有两种选择。一种可能是，它会促使模型记住特定的问答对。这种做法本身并没什么坏处，但不太高效，因为我们的目的是让模型具有泛化能力，并且能回答任何问题，而不只是那些在训练数据中出现的问题。但如果我们使模型在这些情况下能做到泛化，那么实际上就是在教模型捏造答案，相当于鼓励模型“说谎”，这很不好。由于我们无法确定模型知道哪些信息或不知道哪些信息，所以无法避免第二种情况，这对监督训练来说是一个真实且严重的问题。我们不能仅依靠监督学习来训练模型生成可信任回答，还需要强化学习的加持。与监督学习不同，强化学习不会鼓励模型编造答案：即使模型最初确实猜对了一些答案并错误地学习了“编造”行为，但长远来看，模型会因编造答案的得分较低（很可能是不正确的）而学会依赖内部知识或选择放弃回答。
5. 长期以来，使用强化学习训练生成语言任务对大多数玩家来说都不切实际：由于缺乏可靠的自动评分指标，强化学习训练需要对每个训练样本进行人工反馈。这既耗时又昂贵，特别是对于需要查看数千到数万甚至数十万个示例才能学习的模型。然而，强化学习训练现在变得实用了：首先，出现了可以从较少示例中学习的大型预训练语言模型。更重要的是，这些模型为强化学习循环（RL loop）中去掉人类参与铺平了道路。监督训练对于文本相关的任务非常有效，而且大型模型可以很好地学习执行一些任务。例如，让模型确定两个文本是否意思相同，或者一个文本是否包含另一个文本中没有的事实，根据经验来看，大型语言模型（甚至中型语言模型）可以使用监督学习可靠地学习执行这些任务，这为我们提供了可用于强化学习设置的有效自动评分机制。
   

[chatgpt 带来的研究问题](https://www.bilibili.com/video/BV1jA411274Q?p=3)
1. 如何精准提出需求（Prompting）？它不是一个聊天机器人，它只是根据你说的话生成后面的话，得调教它，靠人工还是靠系统？
2. 如果更正错误？chatgpt的预训练资料只有到2021年。**chatgpt 在生成内容的时候，并不真正理解所生成的内容，虽然很多时候它是对的，但因为不理解所以还是会出错**，甚至是一些虚假的内容，这在比如企业客服场景中是不合适的（客服场景以结果为导向，引导客户购买或者 告诉客户哪个更好，有时候需要给出标准答案，比如价格等，这个时候说不知道也比给出错误的结果强，企业很难接受不可控的输出）
3. 侦测一段话是不是AI 生成的。
4. 泄露机密。




## 其它

[大(语言)模型推理原理及加速](https://zhuanlan.zhihu.com/p/628511161)

[投身LLM，要从本质上想明白的三个问题：未来是什么，哪些机会更好，我们要怎么准备](https://mp.weixin.qq.com/s/wWWGP7-lReON_b5-Pm5plg) 好文。

神经网络训练目标是使预测损失最小化，在各个参数展开的空间内找到最优的点，如果从头开始找，会比较慢；但是从之前已经训练好的其他类似模型开始，**就相当于在最优点附近的点开始**，自然收敛的速度和效果会比从零训练好得多。取预训练好的网络的部分结构和权重，与自己新增的网络部分一起训练，称为微调（fine-tune）。

从深度学习发展前10年的历程来看，模型精度提升，主要依赖网络在结构上的变革。 例如，从AlexNet到ResNet50，再到NAS搜索出来的EfficientNet，ImageNet Top-1 精度从58提升到了84。但是，随着神经网络结构设计技术，逐渐成熟并趋于收敛，**想要通过优化神经网络结构从而打破精度局限非常困难**。近年来，随着数据规模和模型规模的不断增大，模型精度也得到了进一步提升，研究实验表明，模型和数据规模的增大确实能突破现有精度的一个局限。

BERT由两阶段构成，每个阶段有自己的特点和目标。第一个阶段是预训练阶段，第二个阶段是Fine-Tuning阶段。预训练阶段用大量无监督的文本通过自监督方式进行训练，把文本包含的语言知识以参数形式编码到Transformer中，Fine-Tuning一般是有监督的，数据量比较小，在模型结构上做分类任务以解决当前任务。第一阶段跟第二阶段怎么连接起来的？在预训练阶段Transformer学到了很多初始化的知识，第二阶段就把初始化网络学到的语言知识拿来用，Fine-Tuning引入新的特征解决你的问题。所以，为什么BERT效果这么好？为什么以前的模型效果没有BERT好？因为，第一阶段编码了文本中大量的语言学知识，在Bert之前，没有用那么多的文本数据，而且是无监督的方式。那么我们关心的是：BERT里的Transformer到底学到了什么？比传统模型多学了什么知识？这是关键。如果归纳一下目前的研究结论的话，大致概述一下：BERT训练好之后，低层Transformer主要学习自然语言表层的特征，中层学习编码句法信息，高层编码了NLP的语义特征。很多实验都已证明这一结论。

[如何利用LLM做多模态任务？](https://mp.weixin.qq.com/s/w_1FdCSD_S-otNVEXytxCQ)

